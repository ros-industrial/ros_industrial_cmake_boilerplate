# Software License Agreement (BSD License)
#
# Copyright (c) 2013, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import argparse
import os
import sys
import traceback
import datetime
import io
import warnings
from pkg_resources import parse_version
from email.utils import formatdate

try:
    to_unicode = unicode
except NameError:
    to_unicode = str

try:
    from catkin_pkg.changelog import get_changelog_from_path
    from catkin_pkg.changelog import CHANGELOG_FILENAME
except ImportError as err:
    debug(traceback.format_exc())
    error("catkin_pkg was not detected, please install it.", exit=True)

try:
    import em
except ImportError:
    debug(traceback.format_exc())
    error("empy was not detected, please install it.", exit=True)


def get_changelogs(package_name,
                   package_maintainer_name,
                   package_maintainer_email,
                   changelog_path,
                   releaser_history=None):
    if releaser_history is None:
        warnings.warn("No historical releaser history, using current maintainer name and email for each versioned "
                      "changelog entry.", Warning)
        releaser_history = {}

    if os.path.exists(changelog_path):
        changelog = get_changelog_from_path(changelog_path)
        changelogs = []
        maintainer = (package_maintainer_name, package_maintainer_email)
        for version, date, changes in changelog.foreach_version(reverse=True):
            changes_str = []
            date_str = formatdate(float(date.strftime("%s")), date.tzinfo)
            for item in changes:
                changes_str.extend(['  ' + i for i in to_unicode(item).splitlines()])
            # Each entry has (version, date, changes, releaser, releaser_email)
            releaser, email = releaser_history.get(version, maintainer)
            changelogs.append((
                version, date_str, '\n'.join(changes_str), releaser, email
            ))
        return changelogs
    else:
        warnings.warn("No {0} found for package '{1}'".format(CHANGELOG_FILENAME, package_name))
        return []


def save_changelog(package_name,
                   package_version,
                   package_maintainer_name,
                   package_maintainer_email,
                   package_distribution,
                   package_debian_increment,
                   package_changelog_path,
                   output_path):
    changelogs = get_changelogs(package_name,
                                package_maintainer_name,
                                package_maintainer_email,
                                package_changelog_path)
    if changelogs and package_version not in [x[0] for x in changelogs]:
        warnings.warn("""
                      A CHANGELOG.rst was found, but no changelog for this version was found.
                      You REALLY should have a entry (even a blank one) for each version of your package.
                      """)
    if not changelogs:
        # Ensure at least a minimal changelog
        changelogs = []
    date = datetime.datetime.now()
    if package_version not in [x[0] for x in changelogs]:
        changelogs.insert(0, (
            package_version,
            formatdate(float(date.strftime("%s")), date.tzinfo),
            '  * Autogenerated, no changelog for this version found in CHANGELOG.rst.',
            package_maintainer_name,
            package_maintainer_email
        ))
    bad_changelog = False
    # Make sure that the first change log is the version being released
    if package_version != changelogs[0][0]:
        warnings.warn("""
                      The version of the first changelog entry '{0}' is not the
                      same as the version being currently released '{1}'.
                      """.format(package_version, changelogs[0][0]))
        bad_changelog = True
    # Make sure that the current version is the latest in the changelog
    for changelog in changelogs:
        if parse_version(package_version) < parse_version(changelog[0]):
            warnings.warn("""
                          There is at least one changelog entry, '{0}', which has a
                          newer version than the version of package '{1}' being released, '{2}'.
                          """.format(changelog[0], package_name, package_version))
            bad_changelog = True
    if bad_changelog:
        sys.exit("This is almost certainly by mistake, you should really take a\nlook at the changelogs for the package '{0}' you are releasing '{1}'.".format(package_name, package_version))

    native = False
    data = {}
    # Debian Increment Number
    data['DebianInc'] = '' if native else '-{0}'.format(package_debian_increment)
    # Package name
    data['Package'] = package_name
    # Package changelogs
    data['changelogs'] = changelogs
    # Package changelogs
    data['Distribution'] = package_distribution

    template = ("@[for change_version, change_date, changelog, main_name, main_email in changelogs]@(Package) (@("
                "change_version)@(DebianInc)@(Distribution)) @(Distribution); urgency=high\n\n@(changelog)\n\n -- @("
                "main_name) <@(main_email)>  @(change_date)\n\n@[end for]\n")

    # Expand template
    result = em.expand(template, **data)
    # Don't write an empty file
    if len(result) == 0:
        error("Failed to expand template")
    # Write the result
    if sys.version_info.major == 2:
        result = result.decode('utf-8')
    output_path.write(result)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.description = "Convert ROS CHANGELOG.rst to debian changelog"
    parser.prog = 'create_debian_changelog'

    parser.add_argument('name', nargs=1, help='The package name', type=str)
    parser.add_argument('version', nargs=1, help='The package version', type=str)
    parser.add_argument('maintainer_name', nargs=1, help='The package maintainer name', type=str)
    parser.add_argument('maintainer_email', nargs=1, help='The package maintainer email', type=str)
    parser.add_argument('distribution', nargs=1, help='The package distribution', type=str)
    parser.add_argument('debian_increment', nargs=1, help='The debian increment', type=str)
    parser.add_argument('changelog_path', nargs=1, help='CHANGELOG.rst file path', type=str)
    parser.add_argument('-o', '--output', help='Debian changelog output file path', default=sys.stdout,
                        type=argparse.FileType('w'))
    arguments = parser.parse_args()
    save_changelog(arguments.name[0],
                   arguments.version[0],
                   arguments.maintainer_name[0],
                   arguments.maintainer_email[0],
                   arguments.distribution[0],
                   arguments.debian_increment[0],
                   arguments.changelog_path[0],
                   arguments.output)
